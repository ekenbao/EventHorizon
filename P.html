<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EKen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script language="javascript">
var noPrint=true;
var noCopy=true;
var noScreenshot=true;
var autoBlur=true;
var noDevTools=true;
var noSaveAs=true;
</script>

<script type="text/javascript" src="noprint.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#6B7280',
                        dark: '#1F2937',
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        /* 设置基础字体大小，用于rem单位计算 */
        html {
            font-size: calc(10px + 0.25vw);
        }
        
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .modal-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 50;
                opacity: 0;
                visibility: hidden;
                /* 移除过渡动画 */
            }
            .modal-backdrop.active {
                opacity: 1;
                visibility: visible;
            }
            .modal-content {
                max-width: 96vw;
                max-height: 96vh;
                display: flex;
                justify-content: center;
                align-items: center;
                /* 移除过渡动画 */
                transform: scale(1); /* 始终保持原始大小 */
                border-radius: 0.7vw; /* 使用vw单位实现响应式圆角 */
                aspect-ratio: 288/167; /* 设置宽高比为2880:1670 */
                background-color: transparent; /* 确保背景透明 */
                overflow: hidden; /* 防止内容溢出 */
            }
            /* 移除激活状态的缩放效果 */
            .modal-backdrop.active .modal-content {
                transform: scale(1); /* 保持原始大小 */
            }
            
            /* 加载动画样式 */
            .loading-spinner {
                border: 5px solid rgba(255, 255, 255, 0.2); /* 20%不透明度的细线 */
                border-top: 5px solid rgba(255, 255, 255, 0.6); /* 60%不透明度的粗线 */
                border-radius: 50%;
                width: 50px;
                height: 50px;
                animation: spin 1s linear infinite;
                position: absolute;
                top: 50%;
                left: 50%;
                margin-top: -25px;
                margin-left: -25px;
                z-index: 100;
            }
            
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        }
    </style>
<body class="bg-black font-inter min-h-screen">


    <main class="container mx-auto px-4 py-8">
        <!-- 移除了多图预览功能，直接显示模态框 -->
    </main>

    <div id="modal" class="modal-backdrop">
        <!-- EP图片容器将通过JavaScript动态创建 -->
    </div>

    <script>
        // 图片数量（只保留EP图片）
        const totalImages = 33; // 现在有33个EP文件夹（01-33）
        const modal = document.getElementById('modal');
        let currentImageIndex = 0;
        
        // 用于存储已预加载的图片
        const preloadedImages = new Set();
        
        // 用于存储已加载的EP小块图片
        const loadedEpParts = {};
        
        // 加载EP小块图片的函数 - 所有图片都是20x20格式
        function loadEpParts(folderName, totalParts) {
            console.log(`开始加载EP/${folderName}，共${totalParts}个部分`);
            
            if (loadedEpParts[folderName]) {
                console.log(`EP/${folderName}已缓存，直接返回`);
                return Promise.resolve(loadedEpParts[folderName]);
            }
            
            return new Promise((resolve, reject) => {
                const parts = [];
                let loadedCount = 0;
                let hasSuccessfulLoad = false;
                
                // 添加超时机制，避免长时间等待
                const timeoutId = setTimeout(() => {
                    console.warn(`EP/${folderName}加载超时，已加载${loadedCount}个部分`);
                    if (hasSuccessfulLoad) {
                        loadedEpParts[folderName] = parts;
                        resolve(parts);
                    } else {
                        reject(new Error(`EP/${folderName}加载超时，无成功加载的部分`));
                    }
                }, 15000); // 15秒超时
                
                for (let i = 1; i <= totalParts; i++) {
                    // 所有文件夹统一使用相同的命名格式
                    const partPath = `EP/${folderName}/${i}.png`;
                    
                    // 为缓存控制添加时间戳
                    const timestamp = new Date().getTime();
                    const cacheBustedPath = `${partPath}?t=${timestamp}`;
                    
                    const img = new Image();
                    const partNumber = i; // 添加partNumber变量
                    // 移除可能导致Chrome兼容性问题的跨域设置
                    // img.crossOrigin = 'anonymous';
                    
                    // 在Chrome中，先设置onload和onerror，再设置src
                    img.onload = function() {
                        console.log(`成功加载${folderName === '04' ? i : partNumber} for EP/${folderName}`);
                        parts[i - 1] = img;
                        loadedCount++;
                        hasSuccessfulLoad = true;
                        
                        if (loadedCount === totalParts) {
                            clearTimeout(timeoutId);
                            loadedEpParts[folderName] = parts;
                            console.log(`EP/${folderName}所有部分加载完成`);
                            resolve(parts);
                        }
                    };
                    
                    img.onerror = function() {
                        console.error(`Failed to load ${folderName === '04' ? i : partNumber} for EP/${folderName}`);
                        // 即使某个部分加载失败，也要继续加载其他部分
                        parts[i - 1] = null; // 标记为加载失败
                        loadedCount++;
                        
                        if (loadedCount === totalParts) {
                            clearTimeout(timeoutId);
                            loadedEpParts[folderName] = parts;
                            console.log(`EP/${folderName}所有部分加载完成（包含失败项）`);
                            resolve(parts);
                        }
                    };
                    
                    // 延迟设置src，确保事件监听器已正确设置
                    setTimeout(() => {
                        img.src = cacheBustedPath;
                    }, 0);
                }
            });
        }
        
        // 创建EP图片容器（使用多个小块图片模拟完整图片）
        // 所有图片都是20x20的网格布局
        function createEpImageContainer(folderName, totalParts, containerWidth, containerHeight, loadingSpinner) {
            // 所有文件夹统一使用20x20的网格布局
            const cols = 20; // 20列
            const rows = 20; // 20行
            
            const container = document.createElement('div');
              container.style.position = 'relative';
              container.style.overflow = 'hidden';
              container.style.margin = '0 auto';
              
              // 计算每个小块的尺寸并取整，确保像素对齐
              const partWidth = Math.floor(containerWidth / cols);
              const partHeight = Math.floor(containerHeight / rows);
              
              // 重新计算实际容器尺寸，确保能被行列数整除
              const actualContainerWidth = partWidth * cols;
              const actualContainerHeight = partHeight * rows;
              
              // 使用重新计算的实际容器尺寸
              container.style.width = `${actualContainerWidth}px`;
              container.style.height = `${actualContainerHeight}px`;
            
            // 创建小块图片的占位符
            for (let i = 0; i < totalParts; i++) {
                const partDiv = document.createElement('div');
                partDiv.style.position = 'absolute';
                partDiv.style.width = `${partWidth}px`;
                partDiv.style.height = `${partHeight}px`;
                partDiv.style.left = `${(i % cols) * partWidth}px`;
                partDiv.style.top = `${Math.floor(i / cols) * partHeight}px`;
                partDiv.style.overflow = 'hidden';
                partDiv.dataset.partIndex = i;
                
                container.appendChild(partDiv);
            }
            
            // 加载并填充小块图片 - 改进Chrome兼容性
            loadEpParts(folderName, totalParts).then(parts => {
                const partDivs = container.querySelectorAll('[data-part-index]');
                let loadedCount = 0;
                const totalPartsCount = parts.length;
                
                parts.forEach((img, index) => {
                    if (partDivs[index] && img) { // 只处理成功加载的图片
                        // 创建新的图片元素而不是克隆，避免Chrome中的潜在问题
                        const imgElement = new Image();
                        imgElement.src = img.src;
                        imgElement.style.width = '100%';
                        imgElement.style.height = '100%';
                        imgElement.style.objectFit = 'cover';
                           
                        // 确保图片加载完成后再添加到DOM
                        imgElement.onload = function() {
                            partDivs[index].appendChild(imgElement);
                            loadedCount++;
                            
                            // 检查是否所有图片都已加载完成
                            if (loadedCount === totalPartsCount && loadingSpinner) {
                                // 隐藏加载动画
                                loadingSpinner.style.display = 'none';
                            }
                        };
                           
                        // 如果图片已经加载完成（缓存中），直接添加
                        if (imgElement.complete) {
                            partDivs[index].appendChild(imgElement);
                            loadedCount++;
                            
                            // 检查是否所有图片都已加载完成
                            if (loadedCount === totalPartsCount && loadingSpinner) {
                                // 隐藏加载动画
                                loadingSpinner.style.display = 'none';
                            }
                        }
                    } else if (partDivs[index]) {
                        // 对于加载失败的部分，显示灰色背景
                        partDivs[index].style.backgroundColor = 'rgba(50, 50, 50, 0.5)';
                        loadedCount++;
                        
                        // 检查是否所有图片都已加载完成
                        if (loadedCount === totalPartsCount && loadingSpinner) {
                            // 隐藏加载动画
                            loadingSpinner.style.display = 'none';
                        }
                    }
                });
                
                // 如果没有图片需要加载，直接隐藏加载动画
                if (totalPartsCount === 0 && loadingSpinner) {
                    loadingSpinner.style.display = 'none';
                }
            }).catch(err => {
                console.error(`Failed to load EP/${folderName}:`, err);
                // 在捕获到错误时，尝试用灰色背景显示所有部分
                const partDivs = container.querySelectorAll('[data-part-index]');
                partDivs.forEach(div => {
                    div.style.backgroundColor = 'rgba(50, 50, 50, 0.5)';
                });
                
                // 隐藏加载动画
                if (loadingSpinner) {
                    loadingSpinner.style.display = 'none';
                }
            });
            
            return container;
        }
        
        // 智能预加载函数：优先加载当前图片，同时预加载前后各两张图片
        function smartPreloadImages(index) {
            // 当前图片、前两张和后两张的索引（循环处理）
            const indicesToLoad = [
                index, // 当前图片
                (index - 2 + totalImages) % totalImages, // 前两张
                (index - 1 + totalImages) % totalImages, // 前一张
                (index + 1) % totalImages, // 后一张
                (index + 2) % totalImages // 后两张
            ];
            
            console.log(`预加载图片索引: ${indicesToLoad.map(i => i + 1).join(', ')}`);
            
            // 预加载这些图片
            indicesToLoad.forEach(i => {
                const folderName = (i + 1).toString().padStart(2, '0');
                if (!preloadedImages.has(folderName)) {
                    preloadedImages.add(folderName);
                    loadEpParts(folderName, 400).catch(err => 
                        console.error(`Preloading EP/${folderName} failed:`, err)
                    );
                }
            });
        }
        
        // 上一张图片
        function showPrevImage() {
            currentImageIndex = (currentImageIndex - 1 + totalImages) % totalImages;
            openModal(currentImageIndex);
            // 预加载新的当前图片的前后各两张
            smartPreloadImages(currentImageIndex);
        }

        // 下一张图片
        function showNextImage() {
            currentImageIndex = (currentImageIndex + 1) % totalImages;
            openModal(currentImageIndex);
            // 预加载新的当前图片的前后各两张
            smartPreloadImages(currentImageIndex);
        }

        // 页面加载时预加载第一张图片及其前后各两张
        window.addEventListener('load', function() {
            // 直接显示第一张图片的模态框
            setTimeout(() => {
                openModal(0);
                // 预加载第一张图片及其前后各两张
                smartPreloadImages(0);
            }, 500); // 延迟500ms以确保页面完全加载
        });

        // 打开模态框
        function openModal(index) {
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            // 使用EP小块图片组合显示
            let epFolder;
            // 所有EP文件夹都使用400个部分（20x20网格）
            const totalParts = 400;
            
            // 格式化为两位数的文件夹名（01-33）
            epFolder = (index + 1).toString().padStart(2, '0');
            
            // 移除之前可能存在的EP容器
            const existingEpModalContainer = document.querySelector('.ep-modal-container');
            if (existingEpModalContainer) {
                existingEpModalContainer.remove();
            }
            
            // 设置模态框中EP图片的尺寸，保持2880:1670的比例
            const aspectRatio = 2880 / 1670; // 设置宽高比为2880:1670
            const maxWidth = window.innerWidth * 0.96; // 设置为窗口宽度的96%
            const maxHeight = window.innerHeight * 0.96; // 高度不超过窗口高度的96%以确保居中
            
            // 根据宽高比和最大尺寸计算最终尺寸
            let containerWidth, containerHeight;
            if (maxWidth / aspectRatio <= maxHeight) {
                // 宽度优先
                containerWidth = Math.floor(maxWidth); // 强制转换为整数像素
                containerHeight = Math.floor(maxWidth / aspectRatio); // 强制转换为整数像素
            } else {
                // 高度优先
                containerHeight = Math.floor(maxHeight); // 强制转换为整数像素
                containerWidth = Math.floor(maxHeight * aspectRatio); // 强制转换为整数像素
            }
            
            // 创建加载动画元素
            const loadingSpinner = document.createElement('div');
            loadingSpinner.className = 'loading-spinner';
            loadingSpinner.style.display = 'block'; // 默认显示加载动画
            
            // 创建EP图片容器（由多个小块图片组成）
            const epModalContainer = createEpImageContainer(epFolder, totalParts, containerWidth, containerHeight, loadingSpinner);
            epModalContainer.className = 'ep-modal-container';
            epModalContainer.style.opacity = '1'; // 直接显示，不使用淡入效果
            epModalContainer.style.position = 'relative';
            epModalContainer.style.borderRadius = '0.7vw'; // 添加圆角效果
            
            // 添加到模态框
            const modalContentWrapper = document.createElement('div');
            modalContentWrapper.className = 'modal-content';
            modalContentWrapper.appendChild(loadingSpinner); // 先添加加载动画
            modalContentWrapper.appendChild(epModalContainer);
            modal.appendChild(modalContentWrapper);
            
            // 监听所有小块图片加载完成
            // 移除加载动画检查，直接显示
        }



        // 点击模态框背景关闭
        // 禁用背景点击关闭





        // 更新EP图片尺寸以适应窗口大小变化
        function updateEpImageSize() {
            const epModalContainer = document.querySelector('.ep-modal-container');
            const modalContentWrapper = document.querySelector('.modal-content');
            
            if (epModalContainer && modalContentWrapper) {
                // 获取当前EP图片信息
                let folderName;
                // 格式化为两位数的文件夹名（01-33）
                folderName = (currentImageIndex + 1).toString().padStart(2, '0');
                
                // 计算新的尺寸，保持2880:1670的比例
                const aspectRatio = 2880 / 1670; // 设置宽高比为2880:1670
                const maxWidth = window.innerWidth * 0.96;
                const maxHeight = window.innerHeight * 0.96; // 统一为96%高度以保持一致性
                
                // 根据宽高比和最大尺寸计算最终尺寸
                let containerWidth, containerHeight;
                if (maxWidth / aspectRatio <= maxHeight) {
                    // 宽度优先
                    containerWidth = Math.floor(maxWidth); // 强制转换为整数像素
                    containerHeight = Math.floor(maxWidth / aspectRatio); // 强制转换为整数像素
                } else {
                    // 高度优先
                    containerHeight = Math.floor(maxHeight); // 强制转换为整数像素
                    containerWidth = Math.floor(maxHeight * aspectRatio); // 强制转换为整数像素
                }
                
                // 更新容器尺寸
                epModalContainer.style.width = `${containerWidth}px`;
                epModalContainer.style.height = `${containerHeight}px`;
                
                // 所有EP文件夹统一使用20x20的网格布局
                const cols = 20;
                const rows = 20;
                const partWidth = Math.floor(containerWidth / cols);
                const partHeight = Math.floor(containerHeight / rows);
                
                // 重新计算实际容器尺寸，确保能被行列数整除
                const actualContainerWidth = partWidth * cols;
                const actualContainerHeight = partHeight * rows;
                
                // 更新容器尺寸为实际尺寸
                epModalContainer.style.width = `${actualContainerWidth}px`;
                epModalContainer.style.height = `${actualContainerHeight}px`;
                
                const partDivs = epModalContainer.querySelectorAll('[data-part-index]');
                partDivs.forEach((div, index) => {
                    div.style.width = `${partWidth}px`;
                    div.style.height = `${partHeight}px`;
                    div.style.left = `${(index % cols) * partWidth}px`;
                    div.style.top = `${Math.floor(index / cols) * partHeight}px`;
                });
            }
        }
        
        // 键盘导航
        document.addEventListener('keydown', function(e) {
            if (modal.classList.contains('active')) {
                if (e.key === 'ArrowLeft') {
                    showPrevImage();
                } else if (e.key === 'ArrowRight') {
                    showNextImage();
                }
            }
        });
        
        // 添加窗口大小改变的事件监听器
        window.addEventListener('resize', updateEpImageSize);
        
        // 移除页面加载动画
    </script>
</body>
</html>